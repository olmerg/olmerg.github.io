<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ejercicio: Distancias y OCR (pedagógico)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
      body { padding:20px; }
      canvas { background:#fff; border:1px solid #333; touch-action: none; }
      #preview { image-rendering: pixelated; }
      .card-header small { color:#666; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 class="mb-3">Ejercicio pedagógico: distancias y OCR</h1>
      <p>Abre este archivo en tu navegador. Dibuja en el lienzo, aprende una letra con <strong>Aprender</strong> y luego prueba <strong>Reconocer</strong>. Los patrones se guardan en el almacenamiento local (localStorage).</p>

      <div class="row">
        <div class="col-md-6">
          <div class="card mb-3">
            <div class="card-header">Lienzo de dibujo</div>
            <div class="card-body text-center">
              <canvas id="draw" width="256" height="256"></canvas>
            </div>
            <div class="card-footer">
              <div class="d-flex gap-2 flex-wrap align-items-center">
                <button id="clear" class="btn btn-sm btn-secondary">Borrar</button>
                <label class="mb-0">Etiqueta (un carácter):</label>
                <input id="label" class="form-control form-control-sm" style="width:80px; display:inline-block;" placeholder="A" />
                <button id="learn" class="btn btn-sm btn-primary">Aprender</button>
                <button id="recognize" class="btn btn-sm btn-success">Reconocer</button>
                <select id="metric" class="form-select form-select-sm" style="width:140px; display:inline-block;">
                  <option value="euclidean">Euclidiana</option>
                  <option value="cityblock">Cityblock (Manhattan)</option>
                  <option value="cosine">Coseno</option>
                </select>
                <button id="export" class="btn btn-sm btn-outline-primary">Exportar patrones</button>
                <input id="importFile" type="file" class="form-control form-control-sm" style="width:180px; display:inline-block;" />
              </div>
              <div class="mt-2 small text-muted">Vista previa 10×14 abajo (muestra lo que usa el algoritmo)</div>
              <canvas id="preview" width="100" height="140" class="mt-2"></canvas>
            </div>
          </div>

          <div class="card">
            <div class="card-header">Estado</div>
            <div class="card-body">
              <div id="status">Listo</div>
            </div>
          </div>
        </div>

        <div class="col-md-6">
          <div class="row">
            <div class="col-12 mb-3">
              <div class="card h-100">
                <div class="card-header">Zona de aprendizaje</div>
                <div class="card-body">
                  <p class="small text-muted">Patrones aprendidos (sobrescribe por simplicidad)</p>
                  <table id="table" class="table table-sm"><thead><tr><th>carácter</th><th>tamaño</th></tr></thead><tbody></tbody></table>
                </div>
              </div>
            </div>

            <div class="col-12">
              <div class="card h-100">
                <div class="card-header">Zona de reconocimiento</div>
                <div class="card-body">
                  <p class="small text-muted">Resultados (distancias desde la muestra actual)</p>
                  <table id="disttab" class="table table-sm"><thead><tr><th>carácter</th><th>distancia</th></tr></thead><tbody></tbody></table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
    // Constants
    const DW = 256, DH = 256;
    const GW = 10, GH = 14;

    // Canvas and drawing
    const canvas = document.getElementById('draw');
    const ctx = canvas.getContext('2d');
    ctx.lineWidth = 12;
    ctx.lineCap = 'round';
    ctx.strokeStyle = '#000';

    let drawing = false; let last = null;
    function pos(e){ const r = canvas.getBoundingClientRect(); let x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left; let y = (e.touches ? e.touches[0].clientY : e.clientY) - r.top; return {x,y}; }
    canvas.addEventListener('pointerdown', (e)=>{ drawing=true; last=pos(e); });
    canvas.addEventListener('pointerup',   (e)=>{ drawing=false; last=null; });
    canvas.addEventListener('pointerout',  (e)=>{ drawing=false; last=null; });
    canvas.addEventListener('pointermove', (e)=>{ if(!drawing) return; const p=pos(e); ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.lineTo(p.x,p.y); ctx.stroke(); last=p; updatePreview(); });
    document.getElementById('clear').onclick = ()=>{ ctx.clearRect(0,0,DW,DH); updatePreview(); }

    // Downsample (same logic)
    function downsample(){
      const image = ctx.getImageData(0,0,DW,DH); const data = image.data;
      let minx=DW, maxx=0, miny=DH, maxy=0, any=false;
      for(let y=0;y<DH;y++)for(let x=0;x<DW;x++){ const idx=(y*DW+x)*4; const a=data[idx+3]; const r=data[idx]; const isInk = a>10 && r<200; if(isInk){ any=true; if(x<minx)minx=x; if(x>maxx)maxx=x; if(y<miny)miny=y; if(y>maxy)maxy=y; } }
      if(!any) return new Array(GW*GH).fill(0);
      minx=Math.max(0,minx-2); miny=Math.max(0,miny-2); maxx=Math.min(DW-1,maxx+2); maxy=Math.min(DH-1,maxy+2);
      const w=maxx-minx+1, h=maxy-miny+1, rx=w/GW, ry=h/GH; const out=[];
      for(let gy=0; gy<GH; gy++){
        for(let gx=0; gx<GW; gx++){
          const sx=Math.floor(minx + gx*rx), sy=Math.floor(miny + gy*ry);
          const ex=Math.min(Math.ceil(minx + (gx+1)*rx), maxx), ey=Math.min(Math.ceil(miny + (gy+1)*ry), maxy);
          let found=false;
          for(let yy=sy; yy<=ey && !found; yy++){
            for(let xx=sx; xx<=ex; xx++){ const idx=(yy*DW+xx)*4; const a=data[idx+3]; const r=data[idx]; if(a>10 && r<200){ found=true; break; } }
          }
          out.push(found?1:0);
        }
      }
      return out;
    }

    function updatePreview(){ const p=downsample(); const pc=document.getElementById('preview'); const pctx=pc.getContext('2d'); pctx.clearRect(0,0,pc.width,pc.height); const sx=pc.width/GW, sy=pc.height/GH; for(let y=0;y<GH;y++)for(let x=0;x<GW;x++){ const v=p[y*GW+x]; pctx.fillStyle=v?'#000':'#fff'; pctx.fillRect(x*sx,y*sy,sx,sy); } }

    // Distances
    function euclidean(a,b){ let s=0; for(let i=0;i<a.length;i++){ const d=a[i]-b[i]; s+=d*d; } return Math.sqrt(s); }
    function cityblock(a,b){ let s=0; for(let i=0;i<a.length;i++){ s+=Math.abs(a[i]-b[i]); } return s; }
    function cosine(a,b){ let na=0, nb=0, dot=0; for(let i=0;i<a.length;i++){ dot+=a[i]*b[i]; na+=a[i]*a[i]; nb+=b[i]*b[i]; } na=Math.sqrt(na); nb=Math.sqrt(nb); if(na===0||nb===0) return 1.0; return 1.0-(dot/(na*nb)); }

    // Persistence
    const STORE_KEY='ocr_patterns_v1'; function load(){ const v=localStorage.getItem(STORE_KEY); if(!v) return {}; try{return JSON.parse(v);}catch(e){return{}} } function save(patterns){ localStorage.setItem(STORE_KEY, JSON.stringify(patterns)); }

    function refreshTable(){ const tb=document.querySelector('#table tbody'); tb.innerHTML=''; const patterns=load(); Object.keys(patterns).sort().forEach(k=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${k}</td><td>${patterns[k].length}</td>`; tb.appendChild(tr); }); }
    function refreshDist(results){ const tb=document.querySelector('#disttab tbody'); tb.innerHTML=''; results.forEach(r=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${r[0]}</td><td>${r[1].toFixed(3)}</td>`; tb.appendChild(tr); }); }

    document.getElementById('learn').onclick = ()=>{
      const ch=document.getElementById('label').value.trim(); if(ch.length!==1){ alert('Ingrese un solo carácter para aprender'); return; }
      const samp=downsample(); const patterns=load(); patterns[ch]=samp; save(patterns); document.getElementById('status').textContent=`Aprendido '${ch}'`; refreshTable(); updatePreview(); }

    document.getElementById('recognize').onclick = ()=>{
      const metric=document.getElementById('metric').value; const samp=downsample(); const patterns=load(); if(Object.keys(patterns).length===0){ alert('No hay patrones aprendidos'); return; }
      const results=[]; Object.keys(patterns).forEach(k=>{ const p=patterns[k]; let d=0; if(metric==='euclidean') d=euclidean(samp,p); else if(metric==='cityblock') d=cityblock(samp,p); else d=cosine(samp,p); results.push([k,d]); }); results.sort((a,b)=>a[1]-b[1]); document.getElementById('status').textContent=`Creo que dibujaste: '${results[0][0]}' (d=${results[0][1].toFixed(3)})`; refreshDist(results); }

    document.getElementById('export').onclick = ()=>{ const data=JSON.stringify(load()); const blob=new Blob([data],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='learn_patterns.json'; a.click(); URL.revokeObjectURL(url); }
    document.getElementById('importFile').onchange = function(e){ const f=this.files[0]; if(!f) return; const r=new FileReader(); r.onload=()=>{ try{ const obj=JSON.parse(r.result); save(obj); refreshTable(); alert('Importado'); }catch(err){ alert('Archivo inválido'); } }; r.readAsText(f); }

    // Init
    refreshTable(); updatePreview();
    </script>
  </body>
</html>
